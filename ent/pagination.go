// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"

	"github.com/suyuan32/simple-admin-file/ent/cloudfile"
	"github.com/suyuan32/simple-admin-file/ent/cloudfiletag"
	"github.com/suyuan32/simple-admin-file/ent/file"
	"github.com/suyuan32/simple-admin-file/ent/filetag"
	"github.com/suyuan32/simple-admin-file/ent/storageprovider"
)

const errInvalidPage = "INVALID_PAGE"

const (
	listField     = "list"
	pageNumField  = "pageNum"
	pageSizeField = "pageSize"
)

type PageDetails struct {
	Page  uint64 `json:"page"`
	Size  uint64 `json:"size"`
	Total uint64 `json:"total"`
}

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

const errInvalidPagination = "INVALID_PAGINATION"

type CloudFilePager struct {
	Order  cloudfile.OrderOption
	Filter func(*CloudFileQuery) (*CloudFileQuery, error)
}

// CloudFilePaginateOption enables pagination customization.
type CloudFilePaginateOption func(*CloudFilePager)

// DefaultCloudFileOrder is the default ordering of CloudFile.
var DefaultCloudFileOrder = Desc(cloudfile.FieldID)

func newCloudFilePager(opts []CloudFilePaginateOption) (*CloudFilePager, error) {
	pager := &CloudFilePager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultCloudFileOrder
	}
	return pager, nil
}

func (p *CloudFilePager) ApplyFilter(query *CloudFileQuery) (*CloudFileQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// CloudFilePageList is CloudFile PageList result.
type CloudFilePageList struct {
	List        []*CloudFile `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (cf *CloudFileQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...CloudFilePaginateOption,
) (*CloudFilePageList, error) {

	pager, err := newCloudFilePager(opts)
	if err != nil {
		return nil, err
	}

	if cf, err = pager.ApplyFilter(cf); err != nil {
		return nil, err
	}

	ret := &CloudFilePageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := cf.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		cf = cf.Order(pager.Order)
	} else {
		cf = cf.Order(DefaultCloudFileOrder)
	}

	cf = cf.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := cf.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type CloudFileTagPager struct {
	Order  cloudfiletag.OrderOption
	Filter func(*CloudFileTagQuery) (*CloudFileTagQuery, error)
}

// CloudFileTagPaginateOption enables pagination customization.
type CloudFileTagPaginateOption func(*CloudFileTagPager)

// DefaultCloudFileTagOrder is the default ordering of CloudFileTag.
var DefaultCloudFileTagOrder = Desc(cloudfiletag.FieldID)

func newCloudFileTagPager(opts []CloudFileTagPaginateOption) (*CloudFileTagPager, error) {
	pager := &CloudFileTagPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultCloudFileTagOrder
	}
	return pager, nil
}

func (p *CloudFileTagPager) ApplyFilter(query *CloudFileTagQuery) (*CloudFileTagQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// CloudFileTagPageList is CloudFileTag PageList result.
type CloudFileTagPageList struct {
	List        []*CloudFileTag `json:"list"`
	PageDetails *PageDetails    `json:"pageDetails"`
}

func (cft *CloudFileTagQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...CloudFileTagPaginateOption,
) (*CloudFileTagPageList, error) {

	pager, err := newCloudFileTagPager(opts)
	if err != nil {
		return nil, err
	}

	if cft, err = pager.ApplyFilter(cft); err != nil {
		return nil, err
	}

	ret := &CloudFileTagPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := cft.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		cft = cft.Order(pager.Order)
	} else {
		cft = cft.Order(DefaultCloudFileTagOrder)
	}

	cft = cft.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := cft.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type FilePager struct {
	Order  file.OrderOption
	Filter func(*FileQuery) (*FileQuery, error)
}

// FilePaginateOption enables pagination customization.
type FilePaginateOption func(*FilePager)

// DefaultFileOrder is the default ordering of File.
var DefaultFileOrder = Desc(file.FieldID)

func newFilePager(opts []FilePaginateOption) (*FilePager, error) {
	pager := &FilePager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultFileOrder
	}
	return pager, nil
}

func (p *FilePager) ApplyFilter(query *FileQuery) (*FileQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// FilePageList is File PageList result.
type FilePageList struct {
	List        []*File      `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (f *FileQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...FilePaginateOption,
) (*FilePageList, error) {

	pager, err := newFilePager(opts)
	if err != nil {
		return nil, err
	}

	if f, err = pager.ApplyFilter(f); err != nil {
		return nil, err
	}

	ret := &FilePageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := f.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		f = f.Order(pager.Order)
	} else {
		f = f.Order(DefaultFileOrder)
	}

	f = f.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := f.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type FileTagPager struct {
	Order  filetag.OrderOption
	Filter func(*FileTagQuery) (*FileTagQuery, error)
}

// FileTagPaginateOption enables pagination customization.
type FileTagPaginateOption func(*FileTagPager)

// DefaultFileTagOrder is the default ordering of FileTag.
var DefaultFileTagOrder = Desc(filetag.FieldID)

func newFileTagPager(opts []FileTagPaginateOption) (*FileTagPager, error) {
	pager := &FileTagPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultFileTagOrder
	}
	return pager, nil
}

func (p *FileTagPager) ApplyFilter(query *FileTagQuery) (*FileTagQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// FileTagPageList is FileTag PageList result.
type FileTagPageList struct {
	List        []*FileTag   `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (ft *FileTagQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...FileTagPaginateOption,
) (*FileTagPageList, error) {

	pager, err := newFileTagPager(opts)
	if err != nil {
		return nil, err
	}

	if ft, err = pager.ApplyFilter(ft); err != nil {
		return nil, err
	}

	ret := &FileTagPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := ft.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		ft = ft.Order(pager.Order)
	} else {
		ft = ft.Order(DefaultFileTagOrder)
	}

	ft = ft.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := ft.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type StorageProviderPager struct {
	Order  storageprovider.OrderOption
	Filter func(*StorageProviderQuery) (*StorageProviderQuery, error)
}

// StorageProviderPaginateOption enables pagination customization.
type StorageProviderPaginateOption func(*StorageProviderPager)

// DefaultStorageProviderOrder is the default ordering of StorageProvider.
var DefaultStorageProviderOrder = Desc(storageprovider.FieldID)

func newStorageProviderPager(opts []StorageProviderPaginateOption) (*StorageProviderPager, error) {
	pager := &StorageProviderPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultStorageProviderOrder
	}
	return pager, nil
}

func (p *StorageProviderPager) ApplyFilter(query *StorageProviderQuery) (*StorageProviderQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// StorageProviderPageList is StorageProvider PageList result.
type StorageProviderPageList struct {
	List        []*StorageProvider `json:"list"`
	PageDetails *PageDetails       `json:"pageDetails"`
}

func (sp *StorageProviderQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...StorageProviderPaginateOption,
) (*StorageProviderPageList, error) {

	pager, err := newStorageProviderPager(opts)
	if err != nil {
		return nil, err
	}

	if sp, err = pager.ApplyFilter(sp); err != nil {
		return nil, err
	}

	ret := &StorageProviderPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := sp.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		sp = sp.Order(pager.Order)
	} else {
		sp = sp.Order(DefaultStorageProviderOrder)
	}

	sp = sp.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := sp.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}
