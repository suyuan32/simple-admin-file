// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	uuid "github.com/gofrs/uuid/v5"
	"github.com/suyuan32/simple-admin-file/ent/cloudfile"
	"github.com/suyuan32/simple-admin-file/ent/cloudfiletag"
	"github.com/suyuan32/simple-admin-file/ent/file"
	"github.com/suyuan32/simple-admin-file/ent/filetag"
	"github.com/suyuan32/simple-admin-file/ent/predicate"
	"github.com/suyuan32/simple-admin-file/ent/storageprovider"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCloudFile       = "CloudFile"
	TypeCloudFileTag    = "CloudFileTag"
	TypeFile            = "File"
	TypeFileTag         = "FileTag"
	TypeStorageProvider = "StorageProvider"
)

// CloudFileMutation represents an operation that mutates the CloudFile nodes in the graph.
type CloudFileMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	created_at               *time.Time
	updated_at               *time.Time
	state                    *bool
	name                     *string
	url                      *string
	size                     *uint64
	addsize                  *int64
	file_type                *uint8
	addfile_type             *int8
	user_id                  *string
	clearedFields            map[string]struct{}
	storage_providers        *uint64
	clearedstorage_providers bool
	tags                     map[uint64]struct{}
	removedtags              map[uint64]struct{}
	clearedtags              bool
	done                     bool
	oldValue                 func(context.Context) (*CloudFile, error)
	predicates               []predicate.CloudFile
}

var _ ent.Mutation = (*CloudFileMutation)(nil)

// cloudfileOption allows management of the mutation configuration using functional options.
type cloudfileOption func(*CloudFileMutation)

// newCloudFileMutation creates new mutation for the CloudFile entity.
func newCloudFileMutation(c config, op Op, opts ...cloudfileOption) *CloudFileMutation {
	m := &CloudFileMutation{
		config:        c,
		op:            op,
		typ:           TypeCloudFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCloudFileID sets the ID field of the mutation.
func withCloudFileID(id uuid.UUID) cloudfileOption {
	return func(m *CloudFileMutation) {
		var (
			err   error
			once  sync.Once
			value *CloudFile
		)
		m.oldValue = func(ctx context.Context) (*CloudFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CloudFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCloudFile sets the old CloudFile of the mutation.
func withCloudFile(node *CloudFile) cloudfileOption {
	return func(m *CloudFileMutation) {
		m.oldValue = func(context.Context) (*CloudFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CloudFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CloudFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CloudFile entities.
func (m *CloudFileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CloudFileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CloudFileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CloudFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CloudFileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CloudFileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CloudFile entity.
// If the CloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CloudFileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CloudFileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CloudFileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CloudFile entity.
// If the CloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CloudFileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetState sets the "state" field.
func (m *CloudFileMutation) SetState(b bool) {
	m.state = &b
}

// State returns the value of the "state" field in the mutation.
func (m *CloudFileMutation) State() (r bool, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the CloudFile entity.
// If the CloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileMutation) OldState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *CloudFileMutation) ClearState() {
	m.state = nil
	m.clearedFields[cloudfile.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *CloudFileMutation) StateCleared() bool {
	_, ok := m.clearedFields[cloudfile.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *CloudFileMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, cloudfile.FieldState)
}

// SetName sets the "name" field.
func (m *CloudFileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CloudFileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CloudFile entity.
// If the CloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CloudFileMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *CloudFileMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *CloudFileMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the CloudFile entity.
// If the CloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *CloudFileMutation) ResetURL() {
	m.url = nil
}

// SetSize sets the "size" field.
func (m *CloudFileMutation) SetSize(u uint64) {
	m.size = &u
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *CloudFileMutation) Size() (r uint64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the CloudFile entity.
// If the CloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileMutation) OldSize(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds u to the "size" field.
func (m *CloudFileMutation) AddSize(u int64) {
	if m.addsize != nil {
		*m.addsize += u
	} else {
		m.addsize = &u
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *CloudFileMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *CloudFileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetFileType sets the "file_type" field.
func (m *CloudFileMutation) SetFileType(u uint8) {
	m.file_type = &u
	m.addfile_type = nil
}

// FileType returns the value of the "file_type" field in the mutation.
func (m *CloudFileMutation) FileType() (r uint8, exists bool) {
	v := m.file_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFileType returns the old "file_type" field's value of the CloudFile entity.
// If the CloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileMutation) OldFileType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileType: %w", err)
	}
	return oldValue.FileType, nil
}

// AddFileType adds u to the "file_type" field.
func (m *CloudFileMutation) AddFileType(u int8) {
	if m.addfile_type != nil {
		*m.addfile_type += u
	} else {
		m.addfile_type = &u
	}
}

// AddedFileType returns the value that was added to the "file_type" field in this mutation.
func (m *CloudFileMutation) AddedFileType() (r int8, exists bool) {
	v := m.addfile_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileType resets all changes to the "file_type" field.
func (m *CloudFileMutation) ResetFileType() {
	m.file_type = nil
	m.addfile_type = nil
}

// SetUserID sets the "user_id" field.
func (m *CloudFileMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CloudFileMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CloudFile entity.
// If the CloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CloudFileMutation) ResetUserID() {
	m.user_id = nil
}

// SetStorageProvidersID sets the "storage_providers" edge to the StorageProvider entity by id.
func (m *CloudFileMutation) SetStorageProvidersID(id uint64) {
	m.storage_providers = &id
}

// ClearStorageProviders clears the "storage_providers" edge to the StorageProvider entity.
func (m *CloudFileMutation) ClearStorageProviders() {
	m.clearedstorage_providers = true
}

// StorageProvidersCleared reports if the "storage_providers" edge to the StorageProvider entity was cleared.
func (m *CloudFileMutation) StorageProvidersCleared() bool {
	return m.clearedstorage_providers
}

// StorageProvidersID returns the "storage_providers" edge ID in the mutation.
func (m *CloudFileMutation) StorageProvidersID() (id uint64, exists bool) {
	if m.storage_providers != nil {
		return *m.storage_providers, true
	}
	return
}

// StorageProvidersIDs returns the "storage_providers" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StorageProvidersID instead. It exists only for internal usage by the builders.
func (m *CloudFileMutation) StorageProvidersIDs() (ids []uint64) {
	if id := m.storage_providers; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStorageProviders resets all changes to the "storage_providers" edge.
func (m *CloudFileMutation) ResetStorageProviders() {
	m.storage_providers = nil
	m.clearedstorage_providers = false
}

// AddTagIDs adds the "tags" edge to the CloudFileTag entity by ids.
func (m *CloudFileMutation) AddTagIDs(ids ...uint64) {
	if m.tags == nil {
		m.tags = make(map[uint64]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the CloudFileTag entity.
func (m *CloudFileMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the CloudFileTag entity was cleared.
func (m *CloudFileMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the CloudFileTag entity by IDs.
func (m *CloudFileMutation) RemoveTagIDs(ids ...uint64) {
	if m.removedtags == nil {
		m.removedtags = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the CloudFileTag entity.
func (m *CloudFileMutation) RemovedTagsIDs() (ids []uint64) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *CloudFileMutation) TagsIDs() (ids []uint64) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *CloudFileMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the CloudFileMutation builder.
func (m *CloudFileMutation) Where(ps ...predicate.CloudFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CloudFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CloudFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CloudFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CloudFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CloudFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CloudFile).
func (m *CloudFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CloudFileMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, cloudfile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cloudfile.FieldUpdatedAt)
	}
	if m.state != nil {
		fields = append(fields, cloudfile.FieldState)
	}
	if m.name != nil {
		fields = append(fields, cloudfile.FieldName)
	}
	if m.url != nil {
		fields = append(fields, cloudfile.FieldURL)
	}
	if m.size != nil {
		fields = append(fields, cloudfile.FieldSize)
	}
	if m.file_type != nil {
		fields = append(fields, cloudfile.FieldFileType)
	}
	if m.user_id != nil {
		fields = append(fields, cloudfile.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CloudFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cloudfile.FieldCreatedAt:
		return m.CreatedAt()
	case cloudfile.FieldUpdatedAt:
		return m.UpdatedAt()
	case cloudfile.FieldState:
		return m.State()
	case cloudfile.FieldName:
		return m.Name()
	case cloudfile.FieldURL:
		return m.URL()
	case cloudfile.FieldSize:
		return m.Size()
	case cloudfile.FieldFileType:
		return m.FileType()
	case cloudfile.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CloudFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cloudfile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cloudfile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cloudfile.FieldState:
		return m.OldState(ctx)
	case cloudfile.FieldName:
		return m.OldName(ctx)
	case cloudfile.FieldURL:
		return m.OldURL(ctx)
	case cloudfile.FieldSize:
		return m.OldSize(ctx)
	case cloudfile.FieldFileType:
		return m.OldFileType(ctx)
	case cloudfile.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown CloudFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CloudFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cloudfile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cloudfile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cloudfile.FieldState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case cloudfile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cloudfile.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case cloudfile.FieldSize:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case cloudfile.FieldFileType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileType(v)
		return nil
	case cloudfile.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown CloudFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CloudFileMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, cloudfile.FieldSize)
	}
	if m.addfile_type != nil {
		fields = append(fields, cloudfile.FieldFileType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CloudFileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cloudfile.FieldSize:
		return m.AddedSize()
	case cloudfile.FieldFileType:
		return m.AddedFileType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CloudFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cloudfile.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case cloudfile.FieldFileType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileType(v)
		return nil
	}
	return fmt.Errorf("unknown CloudFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CloudFileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cloudfile.FieldState) {
		fields = append(fields, cloudfile.FieldState)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CloudFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CloudFileMutation) ClearField(name string) error {
	switch name {
	case cloudfile.FieldState:
		m.ClearState()
		return nil
	}
	return fmt.Errorf("unknown CloudFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CloudFileMutation) ResetField(name string) error {
	switch name {
	case cloudfile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cloudfile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cloudfile.FieldState:
		m.ResetState()
		return nil
	case cloudfile.FieldName:
		m.ResetName()
		return nil
	case cloudfile.FieldURL:
		m.ResetURL()
		return nil
	case cloudfile.FieldSize:
		m.ResetSize()
		return nil
	case cloudfile.FieldFileType:
		m.ResetFileType()
		return nil
	case cloudfile.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown CloudFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CloudFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.storage_providers != nil {
		edges = append(edges, cloudfile.EdgeStorageProviders)
	}
	if m.tags != nil {
		edges = append(edges, cloudfile.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CloudFileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cloudfile.EdgeStorageProviders:
		if id := m.storage_providers; id != nil {
			return []ent.Value{*id}
		}
	case cloudfile.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CloudFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtags != nil {
		edges = append(edges, cloudfile.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CloudFileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cloudfile.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CloudFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstorage_providers {
		edges = append(edges, cloudfile.EdgeStorageProviders)
	}
	if m.clearedtags {
		edges = append(edges, cloudfile.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CloudFileMutation) EdgeCleared(name string) bool {
	switch name {
	case cloudfile.EdgeStorageProviders:
		return m.clearedstorage_providers
	case cloudfile.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CloudFileMutation) ClearEdge(name string) error {
	switch name {
	case cloudfile.EdgeStorageProviders:
		m.ClearStorageProviders()
		return nil
	}
	return fmt.Errorf("unknown CloudFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CloudFileMutation) ResetEdge(name string) error {
	switch name {
	case cloudfile.EdgeStorageProviders:
		m.ResetStorageProviders()
		return nil
	case cloudfile.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown CloudFile edge %s", name)
}

// CloudFileTagMutation represents an operation that mutates the CloudFileTag nodes in the graph.
type CloudFileTagMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint64
	created_at         *time.Time
	updated_at         *time.Time
	status             *uint8
	addstatus          *int8
	name               *string
	remark             *string
	clearedFields      map[string]struct{}
	cloud_files        map[uuid.UUID]struct{}
	removedcloud_files map[uuid.UUID]struct{}
	clearedcloud_files bool
	done               bool
	oldValue           func(context.Context) (*CloudFileTag, error)
	predicates         []predicate.CloudFileTag
}

var _ ent.Mutation = (*CloudFileTagMutation)(nil)

// cloudfiletagOption allows management of the mutation configuration using functional options.
type cloudfiletagOption func(*CloudFileTagMutation)

// newCloudFileTagMutation creates new mutation for the CloudFileTag entity.
func newCloudFileTagMutation(c config, op Op, opts ...cloudfiletagOption) *CloudFileTagMutation {
	m := &CloudFileTagMutation{
		config:        c,
		op:            op,
		typ:           TypeCloudFileTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCloudFileTagID sets the ID field of the mutation.
func withCloudFileTagID(id uint64) cloudfiletagOption {
	return func(m *CloudFileTagMutation) {
		var (
			err   error
			once  sync.Once
			value *CloudFileTag
		)
		m.oldValue = func(ctx context.Context) (*CloudFileTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CloudFileTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCloudFileTag sets the old CloudFileTag of the mutation.
func withCloudFileTag(node *CloudFileTag) cloudfiletagOption {
	return func(m *CloudFileTagMutation) {
		m.oldValue = func(context.Context) (*CloudFileTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CloudFileTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CloudFileTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CloudFileTag entities.
func (m *CloudFileTagMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CloudFileTagMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CloudFileTagMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CloudFileTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CloudFileTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CloudFileTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CloudFileTag entity.
// If the CloudFileTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CloudFileTagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CloudFileTagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CloudFileTagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CloudFileTag entity.
// If the CloudFileTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileTagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CloudFileTagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *CloudFileTagMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CloudFileTagMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CloudFileTag entity.
// If the CloudFileTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileTagMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *CloudFileTagMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CloudFileTagMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *CloudFileTagMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[cloudfiletag.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *CloudFileTagMutation) StatusCleared() bool {
	_, ok := m.clearedFields[cloudfiletag.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *CloudFileTagMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, cloudfiletag.FieldStatus)
}

// SetName sets the "name" field.
func (m *CloudFileTagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CloudFileTagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CloudFileTag entity.
// If the CloudFileTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CloudFileTagMutation) ResetName() {
	m.name = nil
}

// SetRemark sets the "remark" field.
func (m *CloudFileTagMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CloudFileTagMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the CloudFileTag entity.
// If the CloudFileTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileTagMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *CloudFileTagMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[cloudfiletag.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *CloudFileTagMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[cloudfiletag.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *CloudFileTagMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, cloudfiletag.FieldRemark)
}

// AddCloudFileIDs adds the "cloud_files" edge to the CloudFile entity by ids.
func (m *CloudFileTagMutation) AddCloudFileIDs(ids ...uuid.UUID) {
	if m.cloud_files == nil {
		m.cloud_files = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.cloud_files[ids[i]] = struct{}{}
	}
}

// ClearCloudFiles clears the "cloud_files" edge to the CloudFile entity.
func (m *CloudFileTagMutation) ClearCloudFiles() {
	m.clearedcloud_files = true
}

// CloudFilesCleared reports if the "cloud_files" edge to the CloudFile entity was cleared.
func (m *CloudFileTagMutation) CloudFilesCleared() bool {
	return m.clearedcloud_files
}

// RemoveCloudFileIDs removes the "cloud_files" edge to the CloudFile entity by IDs.
func (m *CloudFileTagMutation) RemoveCloudFileIDs(ids ...uuid.UUID) {
	if m.removedcloud_files == nil {
		m.removedcloud_files = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.cloud_files, ids[i])
		m.removedcloud_files[ids[i]] = struct{}{}
	}
}

// RemovedCloudFiles returns the removed IDs of the "cloud_files" edge to the CloudFile entity.
func (m *CloudFileTagMutation) RemovedCloudFilesIDs() (ids []uuid.UUID) {
	for id := range m.removedcloud_files {
		ids = append(ids, id)
	}
	return
}

// CloudFilesIDs returns the "cloud_files" edge IDs in the mutation.
func (m *CloudFileTagMutation) CloudFilesIDs() (ids []uuid.UUID) {
	for id := range m.cloud_files {
		ids = append(ids, id)
	}
	return
}

// ResetCloudFiles resets all changes to the "cloud_files" edge.
func (m *CloudFileTagMutation) ResetCloudFiles() {
	m.cloud_files = nil
	m.clearedcloud_files = false
	m.removedcloud_files = nil
}

// Where appends a list predicates to the CloudFileTagMutation builder.
func (m *CloudFileTagMutation) Where(ps ...predicate.CloudFileTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CloudFileTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CloudFileTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CloudFileTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CloudFileTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CloudFileTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CloudFileTag).
func (m *CloudFileTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CloudFileTagMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, cloudfiletag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cloudfiletag.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, cloudfiletag.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, cloudfiletag.FieldName)
	}
	if m.remark != nil {
		fields = append(fields, cloudfiletag.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CloudFileTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cloudfiletag.FieldCreatedAt:
		return m.CreatedAt()
	case cloudfiletag.FieldUpdatedAt:
		return m.UpdatedAt()
	case cloudfiletag.FieldStatus:
		return m.Status()
	case cloudfiletag.FieldName:
		return m.Name()
	case cloudfiletag.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CloudFileTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cloudfiletag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cloudfiletag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cloudfiletag.FieldStatus:
		return m.OldStatus(ctx)
	case cloudfiletag.FieldName:
		return m.OldName(ctx)
	case cloudfiletag.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown CloudFileTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CloudFileTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cloudfiletag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cloudfiletag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cloudfiletag.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case cloudfiletag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cloudfiletag.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown CloudFileTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CloudFileTagMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, cloudfiletag.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CloudFileTagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cloudfiletag.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CloudFileTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cloudfiletag.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown CloudFileTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CloudFileTagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cloudfiletag.FieldStatus) {
		fields = append(fields, cloudfiletag.FieldStatus)
	}
	if m.FieldCleared(cloudfiletag.FieldRemark) {
		fields = append(fields, cloudfiletag.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CloudFileTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CloudFileTagMutation) ClearField(name string) error {
	switch name {
	case cloudfiletag.FieldStatus:
		m.ClearStatus()
		return nil
	case cloudfiletag.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown CloudFileTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CloudFileTagMutation) ResetField(name string) error {
	switch name {
	case cloudfiletag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cloudfiletag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cloudfiletag.FieldStatus:
		m.ResetStatus()
		return nil
	case cloudfiletag.FieldName:
		m.ResetName()
		return nil
	case cloudfiletag.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown CloudFileTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CloudFileTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cloud_files != nil {
		edges = append(edges, cloudfiletag.EdgeCloudFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CloudFileTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cloudfiletag.EdgeCloudFiles:
		ids := make([]ent.Value, 0, len(m.cloud_files))
		for id := range m.cloud_files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CloudFileTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcloud_files != nil {
		edges = append(edges, cloudfiletag.EdgeCloudFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CloudFileTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cloudfiletag.EdgeCloudFiles:
		ids := make([]ent.Value, 0, len(m.removedcloud_files))
		for id := range m.removedcloud_files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CloudFileTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcloud_files {
		edges = append(edges, cloudfiletag.EdgeCloudFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CloudFileTagMutation) EdgeCleared(name string) bool {
	switch name {
	case cloudfiletag.EdgeCloudFiles:
		return m.clearedcloud_files
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CloudFileTagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CloudFileTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CloudFileTagMutation) ResetEdge(name string) error {
	switch name {
	case cloudfiletag.EdgeCloudFiles:
		m.ResetCloudFiles()
		return nil
	}
	return fmt.Errorf("unknown CloudFileTag edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	status        *uint8
	addstatus     *int8
	name          *string
	file_type     *uint8
	addfile_type  *int8
	size          *uint64
	addsize       *int64
	_path         *string
	user_id       *string
	md5           *string
	clearedFields map[string]struct{}
	tags          map[uint64]struct{}
	removedtags   map[uint64]struct{}
	clearedtags   bool
	done          bool
	oldValue      func(context.Context) (*File, error)
	predicates    []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id uuid.UUID) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of File entities.
func (m *FileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *FileMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *FileMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *FileMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *FileMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *FileMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[file.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *FileMutation) StatusCleared() bool {
	_, ok := m.clearedFields[file.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *FileMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, file.FieldStatus)
}

// SetName sets the "name" field.
func (m *FileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FileMutation) ResetName() {
	m.name = nil
}

// SetFileType sets the "file_type" field.
func (m *FileMutation) SetFileType(u uint8) {
	m.file_type = &u
	m.addfile_type = nil
}

// FileType returns the value of the "file_type" field in the mutation.
func (m *FileMutation) FileType() (r uint8, exists bool) {
	v := m.file_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFileType returns the old "file_type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldFileType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileType: %w", err)
	}
	return oldValue.FileType, nil
}

// AddFileType adds u to the "file_type" field.
func (m *FileMutation) AddFileType(u int8) {
	if m.addfile_type != nil {
		*m.addfile_type += u
	} else {
		m.addfile_type = &u
	}
}

// AddedFileType returns the value that was added to the "file_type" field in this mutation.
func (m *FileMutation) AddedFileType() (r int8, exists bool) {
	v := m.addfile_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileType resets all changes to the "file_type" field.
func (m *FileMutation) ResetFileType() {
	m.file_type = nil
	m.addfile_type = nil
}

// SetSize sets the "size" field.
func (m *FileMutation) SetSize(u uint64) {
	m.size = &u
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FileMutation) Size() (r uint64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds u to the "size" field.
func (m *FileMutation) AddSize(u int64) {
	if m.addsize != nil {
		*m.addsize += u
	} else {
		m.addsize = &u
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FileMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *FileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetPath sets the "path" field.
func (m *FileMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *FileMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *FileMutation) ResetPath() {
	m._path = nil
}

// SetUserID sets the "user_id" field.
func (m *FileMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *FileMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *FileMutation) ResetUserID() {
	m.user_id = nil
}

// SetMd5 sets the "md5" field.
func (m *FileMutation) SetMd5(s string) {
	m.md5 = &s
}

// Md5 returns the value of the "md5" field in the mutation.
func (m *FileMutation) Md5() (r string, exists bool) {
	v := m.md5
	if v == nil {
		return
	}
	return *v, true
}

// OldMd5 returns the old "md5" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldMd5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMd5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMd5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMd5: %w", err)
	}
	return oldValue.Md5, nil
}

// ResetMd5 resets all changes to the "md5" field.
func (m *FileMutation) ResetMd5() {
	m.md5 = nil
}

// AddTagIDs adds the "tags" edge to the FileTag entity by ids.
func (m *FileMutation) AddTagIDs(ids ...uint64) {
	if m.tags == nil {
		m.tags = make(map[uint64]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the FileTag entity.
func (m *FileMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the FileTag entity was cleared.
func (m *FileMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the FileTag entity by IDs.
func (m *FileMutation) RemoveTagIDs(ids ...uint64) {
	if m.removedtags == nil {
		m.removedtags = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the FileTag entity.
func (m *FileMutation) RemovedTagsIDs() (ids []uint64) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *FileMutation) TagsIDs() (ids []uint64) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *FileMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, file.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, file.FieldName)
	}
	if m.file_type != nil {
		fields = append(fields, file.FieldFileType)
	}
	if m.size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m._path != nil {
		fields = append(fields, file.FieldPath)
	}
	if m.user_id != nil {
		fields = append(fields, file.FieldUserID)
	}
	if m.md5 != nil {
		fields = append(fields, file.FieldMd5)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldCreatedAt:
		return m.CreatedAt()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	case file.FieldStatus:
		return m.Status()
	case file.FieldName:
		return m.Name()
	case file.FieldFileType:
		return m.FileType()
	case file.FieldSize:
		return m.Size()
	case file.FieldPath:
		return m.Path()
	case file.FieldUserID:
		return m.UserID()
	case file.FieldMd5:
		return m.Md5()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case file.FieldStatus:
		return m.OldStatus(ctx)
	case file.FieldName:
		return m.OldName(ctx)
	case file.FieldFileType:
		return m.OldFileType(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldPath:
		return m.OldPath(ctx)
	case file.FieldUserID:
		return m.OldUserID(ctx)
	case file.FieldMd5:
		return m.OldMd5(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case file.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case file.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case file.FieldFileType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileType(v)
		return nil
	case file.FieldSize:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case file.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case file.FieldMd5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMd5(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, file.FieldStatus)
	}
	if m.addfile_type != nil {
		fields = append(fields, file.FieldFileType)
	}
	if m.addsize != nil {
		fields = append(fields, file.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldStatus:
		return m.AddedStatus()
	case file.FieldFileType:
		return m.AddedFileType()
	case file.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case file.FieldFileType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileType(v)
		return nil
	case file.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldStatus) {
		fields = append(fields, file.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case file.FieldStatus:
		m.ResetStatus()
		return nil
	case file.FieldName:
		m.ResetName()
		return nil
	case file.FieldFileType:
		m.ResetFileType()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldPath:
		m.ResetPath()
		return nil
	case file.FieldUserID:
		m.ResetUserID()
		return nil
	case file.FieldMd5:
		m.ResetMd5()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tags != nil {
		edges = append(edges, file.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtags != nil {
		edges = append(edges, file.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtags {
		edges = append(edges, file.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// FileTagMutation represents an operation that mutates the FileTag nodes in the graph.
type FileTagMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	status        *uint8
	addstatus     *int8
	name          *string
	remark        *string
	clearedFields map[string]struct{}
	files         map[uuid.UUID]struct{}
	removedfiles  map[uuid.UUID]struct{}
	clearedfiles  bool
	done          bool
	oldValue      func(context.Context) (*FileTag, error)
	predicates    []predicate.FileTag
}

var _ ent.Mutation = (*FileTagMutation)(nil)

// filetagOption allows management of the mutation configuration using functional options.
type filetagOption func(*FileTagMutation)

// newFileTagMutation creates new mutation for the FileTag entity.
func newFileTagMutation(c config, op Op, opts ...filetagOption) *FileTagMutation {
	m := &FileTagMutation{
		config:        c,
		op:            op,
		typ:           TypeFileTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileTagID sets the ID field of the mutation.
func withFileTagID(id uint64) filetagOption {
	return func(m *FileTagMutation) {
		var (
			err   error
			once  sync.Once
			value *FileTag
		)
		m.oldValue = func(ctx context.Context) (*FileTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileTag sets the old FileTag of the mutation.
func withFileTag(node *FileTag) filetagOption {
	return func(m *FileTagMutation) {
		m.oldValue = func(context.Context) (*FileTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FileTag entities.
func (m *FileTagMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileTagMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileTagMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FileTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FileTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FileTag entity.
// If the FileTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileTagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileTagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileTagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FileTag entity.
// If the FileTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileTagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileTagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *FileTagMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *FileTagMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the FileTag entity.
// If the FileTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileTagMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *FileTagMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *FileTagMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *FileTagMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[filetag.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *FileTagMutation) StatusCleared() bool {
	_, ok := m.clearedFields[filetag.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *FileTagMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, filetag.FieldStatus)
}

// SetName sets the "name" field.
func (m *FileTagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FileTagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FileTag entity.
// If the FileTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FileTagMutation) ResetName() {
	m.name = nil
}

// SetRemark sets the "remark" field.
func (m *FileTagMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *FileTagMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the FileTag entity.
// If the FileTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileTagMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *FileTagMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[filetag.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *FileTagMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[filetag.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *FileTagMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, filetag.FieldRemark)
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *FileTagMutation) AddFileIDs(ids ...uuid.UUID) {
	if m.files == nil {
		m.files = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *FileTagMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *FileTagMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *FileTagMutation) RemoveFileIDs(ids ...uuid.UUID) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *FileTagMutation) RemovedFilesIDs() (ids []uuid.UUID) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *FileTagMutation) FilesIDs() (ids []uuid.UUID) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *FileTagMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// Where appends a list predicates to the FileTagMutation builder.
func (m *FileTagMutation) Where(ps ...predicate.FileTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FileTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FileTag).
func (m *FileTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileTagMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, filetag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, filetag.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, filetag.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, filetag.FieldName)
	}
	if m.remark != nil {
		fields = append(fields, filetag.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filetag.FieldCreatedAt:
		return m.CreatedAt()
	case filetag.FieldUpdatedAt:
		return m.UpdatedAt()
	case filetag.FieldStatus:
		return m.Status()
	case filetag.FieldName:
		return m.Name()
	case filetag.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filetag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case filetag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case filetag.FieldStatus:
		return m.OldStatus(ctx)
	case filetag.FieldName:
		return m.OldName(ctx)
	case filetag.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown FileTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filetag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case filetag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case filetag.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case filetag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case filetag.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown FileTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileTagMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, filetag.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileTagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case filetag.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case filetag.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown FileTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileTagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(filetag.FieldStatus) {
		fields = append(fields, filetag.FieldStatus)
	}
	if m.FieldCleared(filetag.FieldRemark) {
		fields = append(fields, filetag.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileTagMutation) ClearField(name string) error {
	switch name {
	case filetag.FieldStatus:
		m.ClearStatus()
		return nil
	case filetag.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown FileTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileTagMutation) ResetField(name string) error {
	switch name {
	case filetag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case filetag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case filetag.FieldStatus:
		m.ResetStatus()
		return nil
	case filetag.FieldName:
		m.ResetName()
		return nil
	case filetag.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown FileTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.files != nil {
		edges = append(edges, filetag.EdgeFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case filetag.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedfiles != nil {
		edges = append(edges, filetag.EdgeFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case filetag.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfiles {
		edges = append(edges, filetag.EdgeFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileTagMutation) EdgeCleared(name string) bool {
	switch name {
	case filetag.EdgeFiles:
		return m.clearedfiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileTagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FileTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileTagMutation) ResetEdge(name string) error {
	switch name {
	case filetag.EdgeFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown FileTag edge %s", name)
}

// StorageProviderMutation represents an operation that mutates the StorageProvider nodes in the graph.
type StorageProviderMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	state             *bool
	name              *string
	bucket            *string
	secret_id         *string
	secret_key        *string
	endpoint          *string
	folder            *string
	region            *string
	is_default        *bool
	use_cdn           *bool
	cdn_url           *string
	clearedFields     map[string]struct{}
	cloudfiles        map[uuid.UUID]struct{}
	removedcloudfiles map[uuid.UUID]struct{}
	clearedcloudfiles bool
	done              bool
	oldValue          func(context.Context) (*StorageProvider, error)
	predicates        []predicate.StorageProvider
}

var _ ent.Mutation = (*StorageProviderMutation)(nil)

// storageproviderOption allows management of the mutation configuration using functional options.
type storageproviderOption func(*StorageProviderMutation)

// newStorageProviderMutation creates new mutation for the StorageProvider entity.
func newStorageProviderMutation(c config, op Op, opts ...storageproviderOption) *StorageProviderMutation {
	m := &StorageProviderMutation{
		config:        c,
		op:            op,
		typ:           TypeStorageProvider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStorageProviderID sets the ID field of the mutation.
func withStorageProviderID(id uint64) storageproviderOption {
	return func(m *StorageProviderMutation) {
		var (
			err   error
			once  sync.Once
			value *StorageProvider
		)
		m.oldValue = func(ctx context.Context) (*StorageProvider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StorageProvider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStorageProvider sets the old StorageProvider of the mutation.
func withStorageProvider(node *StorageProvider) storageproviderOption {
	return func(m *StorageProviderMutation) {
		m.oldValue = func(context.Context) (*StorageProvider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StorageProviderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StorageProviderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StorageProvider entities.
func (m *StorageProviderMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StorageProviderMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StorageProviderMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StorageProvider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StorageProviderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StorageProviderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StorageProvider entity.
// If the StorageProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageProviderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StorageProviderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StorageProviderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StorageProviderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StorageProvider entity.
// If the StorageProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageProviderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StorageProviderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetState sets the "state" field.
func (m *StorageProviderMutation) SetState(b bool) {
	m.state = &b
}

// State returns the value of the "state" field in the mutation.
func (m *StorageProviderMutation) State() (r bool, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the StorageProvider entity.
// If the StorageProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageProviderMutation) OldState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *StorageProviderMutation) ClearState() {
	m.state = nil
	m.clearedFields[storageprovider.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *StorageProviderMutation) StateCleared() bool {
	_, ok := m.clearedFields[storageprovider.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *StorageProviderMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, storageprovider.FieldState)
}

// SetName sets the "name" field.
func (m *StorageProviderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StorageProviderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the StorageProvider entity.
// If the StorageProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageProviderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StorageProviderMutation) ResetName() {
	m.name = nil
}

// SetBucket sets the "bucket" field.
func (m *StorageProviderMutation) SetBucket(s string) {
	m.bucket = &s
}

// Bucket returns the value of the "bucket" field in the mutation.
func (m *StorageProviderMutation) Bucket() (r string, exists bool) {
	v := m.bucket
	if v == nil {
		return
	}
	return *v, true
}

// OldBucket returns the old "bucket" field's value of the StorageProvider entity.
// If the StorageProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageProviderMutation) OldBucket(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBucket is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBucket requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucket: %w", err)
	}
	return oldValue.Bucket, nil
}

// ResetBucket resets all changes to the "bucket" field.
func (m *StorageProviderMutation) ResetBucket() {
	m.bucket = nil
}

// SetSecretID sets the "secret_id" field.
func (m *StorageProviderMutation) SetSecretID(s string) {
	m.secret_id = &s
}

// SecretID returns the value of the "secret_id" field in the mutation.
func (m *StorageProviderMutation) SecretID() (r string, exists bool) {
	v := m.secret_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretID returns the old "secret_id" field's value of the StorageProvider entity.
// If the StorageProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageProviderMutation) OldSecretID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretID: %w", err)
	}
	return oldValue.SecretID, nil
}

// ResetSecretID resets all changes to the "secret_id" field.
func (m *StorageProviderMutation) ResetSecretID() {
	m.secret_id = nil
}

// SetSecretKey sets the "secret_key" field.
func (m *StorageProviderMutation) SetSecretKey(s string) {
	m.secret_key = &s
}

// SecretKey returns the value of the "secret_key" field in the mutation.
func (m *StorageProviderMutation) SecretKey() (r string, exists bool) {
	v := m.secret_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretKey returns the old "secret_key" field's value of the StorageProvider entity.
// If the StorageProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageProviderMutation) OldSecretKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretKey: %w", err)
	}
	return oldValue.SecretKey, nil
}

// ResetSecretKey resets all changes to the "secret_key" field.
func (m *StorageProviderMutation) ResetSecretKey() {
	m.secret_key = nil
}

// SetEndpoint sets the "endpoint" field.
func (m *StorageProviderMutation) SetEndpoint(s string) {
	m.endpoint = &s
}

// Endpoint returns the value of the "endpoint" field in the mutation.
func (m *StorageProviderMutation) Endpoint() (r string, exists bool) {
	v := m.endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpoint returns the old "endpoint" field's value of the StorageProvider entity.
// If the StorageProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageProviderMutation) OldEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpoint: %w", err)
	}
	return oldValue.Endpoint, nil
}

// ResetEndpoint resets all changes to the "endpoint" field.
func (m *StorageProviderMutation) ResetEndpoint() {
	m.endpoint = nil
}

// SetFolder sets the "folder" field.
func (m *StorageProviderMutation) SetFolder(s string) {
	m.folder = &s
}

// Folder returns the value of the "folder" field in the mutation.
func (m *StorageProviderMutation) Folder() (r string, exists bool) {
	v := m.folder
	if v == nil {
		return
	}
	return *v, true
}

// OldFolder returns the old "folder" field's value of the StorageProvider entity.
// If the StorageProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageProviderMutation) OldFolder(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFolder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFolder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFolder: %w", err)
	}
	return oldValue.Folder, nil
}

// ClearFolder clears the value of the "folder" field.
func (m *StorageProviderMutation) ClearFolder() {
	m.folder = nil
	m.clearedFields[storageprovider.FieldFolder] = struct{}{}
}

// FolderCleared returns if the "folder" field was cleared in this mutation.
func (m *StorageProviderMutation) FolderCleared() bool {
	_, ok := m.clearedFields[storageprovider.FieldFolder]
	return ok
}

// ResetFolder resets all changes to the "folder" field.
func (m *StorageProviderMutation) ResetFolder() {
	m.folder = nil
	delete(m.clearedFields, storageprovider.FieldFolder)
}

// SetRegion sets the "region" field.
func (m *StorageProviderMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the value of the "region" field in the mutation.
func (m *StorageProviderMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the StorageProvider entity.
// If the StorageProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageProviderMutation) OldRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ResetRegion resets all changes to the "region" field.
func (m *StorageProviderMutation) ResetRegion() {
	m.region = nil
}

// SetIsDefault sets the "is_default" field.
func (m *StorageProviderMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *StorageProviderMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the StorageProvider entity.
// If the StorageProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageProviderMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *StorageProviderMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetUseCdn sets the "use_cdn" field.
func (m *StorageProviderMutation) SetUseCdn(b bool) {
	m.use_cdn = &b
}

// UseCdn returns the value of the "use_cdn" field in the mutation.
func (m *StorageProviderMutation) UseCdn() (r bool, exists bool) {
	v := m.use_cdn
	if v == nil {
		return
	}
	return *v, true
}

// OldUseCdn returns the old "use_cdn" field's value of the StorageProvider entity.
// If the StorageProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageProviderMutation) OldUseCdn(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseCdn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseCdn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseCdn: %w", err)
	}
	return oldValue.UseCdn, nil
}

// ResetUseCdn resets all changes to the "use_cdn" field.
func (m *StorageProviderMutation) ResetUseCdn() {
	m.use_cdn = nil
}

// SetCdnURL sets the "cdn_url" field.
func (m *StorageProviderMutation) SetCdnURL(s string) {
	m.cdn_url = &s
}

// CdnURL returns the value of the "cdn_url" field in the mutation.
func (m *StorageProviderMutation) CdnURL() (r string, exists bool) {
	v := m.cdn_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCdnURL returns the old "cdn_url" field's value of the StorageProvider entity.
// If the StorageProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageProviderMutation) OldCdnURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCdnURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCdnURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCdnURL: %w", err)
	}
	return oldValue.CdnURL, nil
}

// ClearCdnURL clears the value of the "cdn_url" field.
func (m *StorageProviderMutation) ClearCdnURL() {
	m.cdn_url = nil
	m.clearedFields[storageprovider.FieldCdnURL] = struct{}{}
}

// CdnURLCleared returns if the "cdn_url" field was cleared in this mutation.
func (m *StorageProviderMutation) CdnURLCleared() bool {
	_, ok := m.clearedFields[storageprovider.FieldCdnURL]
	return ok
}

// ResetCdnURL resets all changes to the "cdn_url" field.
func (m *StorageProviderMutation) ResetCdnURL() {
	m.cdn_url = nil
	delete(m.clearedFields, storageprovider.FieldCdnURL)
}

// AddCloudfileIDs adds the "cloudfiles" edge to the CloudFile entity by ids.
func (m *StorageProviderMutation) AddCloudfileIDs(ids ...uuid.UUID) {
	if m.cloudfiles == nil {
		m.cloudfiles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.cloudfiles[ids[i]] = struct{}{}
	}
}

// ClearCloudfiles clears the "cloudfiles" edge to the CloudFile entity.
func (m *StorageProviderMutation) ClearCloudfiles() {
	m.clearedcloudfiles = true
}

// CloudfilesCleared reports if the "cloudfiles" edge to the CloudFile entity was cleared.
func (m *StorageProviderMutation) CloudfilesCleared() bool {
	return m.clearedcloudfiles
}

// RemoveCloudfileIDs removes the "cloudfiles" edge to the CloudFile entity by IDs.
func (m *StorageProviderMutation) RemoveCloudfileIDs(ids ...uuid.UUID) {
	if m.removedcloudfiles == nil {
		m.removedcloudfiles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.cloudfiles, ids[i])
		m.removedcloudfiles[ids[i]] = struct{}{}
	}
}

// RemovedCloudfiles returns the removed IDs of the "cloudfiles" edge to the CloudFile entity.
func (m *StorageProviderMutation) RemovedCloudfilesIDs() (ids []uuid.UUID) {
	for id := range m.removedcloudfiles {
		ids = append(ids, id)
	}
	return
}

// CloudfilesIDs returns the "cloudfiles" edge IDs in the mutation.
func (m *StorageProviderMutation) CloudfilesIDs() (ids []uuid.UUID) {
	for id := range m.cloudfiles {
		ids = append(ids, id)
	}
	return
}

// ResetCloudfiles resets all changes to the "cloudfiles" edge.
func (m *StorageProviderMutation) ResetCloudfiles() {
	m.cloudfiles = nil
	m.clearedcloudfiles = false
	m.removedcloudfiles = nil
}

// Where appends a list predicates to the StorageProviderMutation builder.
func (m *StorageProviderMutation) Where(ps ...predicate.StorageProvider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StorageProviderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StorageProviderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StorageProvider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StorageProviderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StorageProviderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StorageProvider).
func (m *StorageProviderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StorageProviderMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, storageprovider.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, storageprovider.FieldUpdatedAt)
	}
	if m.state != nil {
		fields = append(fields, storageprovider.FieldState)
	}
	if m.name != nil {
		fields = append(fields, storageprovider.FieldName)
	}
	if m.bucket != nil {
		fields = append(fields, storageprovider.FieldBucket)
	}
	if m.secret_id != nil {
		fields = append(fields, storageprovider.FieldSecretID)
	}
	if m.secret_key != nil {
		fields = append(fields, storageprovider.FieldSecretKey)
	}
	if m.endpoint != nil {
		fields = append(fields, storageprovider.FieldEndpoint)
	}
	if m.folder != nil {
		fields = append(fields, storageprovider.FieldFolder)
	}
	if m.region != nil {
		fields = append(fields, storageprovider.FieldRegion)
	}
	if m.is_default != nil {
		fields = append(fields, storageprovider.FieldIsDefault)
	}
	if m.use_cdn != nil {
		fields = append(fields, storageprovider.FieldUseCdn)
	}
	if m.cdn_url != nil {
		fields = append(fields, storageprovider.FieldCdnURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StorageProviderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case storageprovider.FieldCreatedAt:
		return m.CreatedAt()
	case storageprovider.FieldUpdatedAt:
		return m.UpdatedAt()
	case storageprovider.FieldState:
		return m.State()
	case storageprovider.FieldName:
		return m.Name()
	case storageprovider.FieldBucket:
		return m.Bucket()
	case storageprovider.FieldSecretID:
		return m.SecretID()
	case storageprovider.FieldSecretKey:
		return m.SecretKey()
	case storageprovider.FieldEndpoint:
		return m.Endpoint()
	case storageprovider.FieldFolder:
		return m.Folder()
	case storageprovider.FieldRegion:
		return m.Region()
	case storageprovider.FieldIsDefault:
		return m.IsDefault()
	case storageprovider.FieldUseCdn:
		return m.UseCdn()
	case storageprovider.FieldCdnURL:
		return m.CdnURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StorageProviderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case storageprovider.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case storageprovider.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case storageprovider.FieldState:
		return m.OldState(ctx)
	case storageprovider.FieldName:
		return m.OldName(ctx)
	case storageprovider.FieldBucket:
		return m.OldBucket(ctx)
	case storageprovider.FieldSecretID:
		return m.OldSecretID(ctx)
	case storageprovider.FieldSecretKey:
		return m.OldSecretKey(ctx)
	case storageprovider.FieldEndpoint:
		return m.OldEndpoint(ctx)
	case storageprovider.FieldFolder:
		return m.OldFolder(ctx)
	case storageprovider.FieldRegion:
		return m.OldRegion(ctx)
	case storageprovider.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case storageprovider.FieldUseCdn:
		return m.OldUseCdn(ctx)
	case storageprovider.FieldCdnURL:
		return m.OldCdnURL(ctx)
	}
	return nil, fmt.Errorf("unknown StorageProvider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StorageProviderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case storageprovider.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case storageprovider.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case storageprovider.FieldState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case storageprovider.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case storageprovider.FieldBucket:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucket(v)
		return nil
	case storageprovider.FieldSecretID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretID(v)
		return nil
	case storageprovider.FieldSecretKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretKey(v)
		return nil
	case storageprovider.FieldEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpoint(v)
		return nil
	case storageprovider.FieldFolder:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFolder(v)
		return nil
	case storageprovider.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case storageprovider.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case storageprovider.FieldUseCdn:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseCdn(v)
		return nil
	case storageprovider.FieldCdnURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCdnURL(v)
		return nil
	}
	return fmt.Errorf("unknown StorageProvider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StorageProviderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StorageProviderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StorageProviderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StorageProvider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StorageProviderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(storageprovider.FieldState) {
		fields = append(fields, storageprovider.FieldState)
	}
	if m.FieldCleared(storageprovider.FieldFolder) {
		fields = append(fields, storageprovider.FieldFolder)
	}
	if m.FieldCleared(storageprovider.FieldCdnURL) {
		fields = append(fields, storageprovider.FieldCdnURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StorageProviderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StorageProviderMutation) ClearField(name string) error {
	switch name {
	case storageprovider.FieldState:
		m.ClearState()
		return nil
	case storageprovider.FieldFolder:
		m.ClearFolder()
		return nil
	case storageprovider.FieldCdnURL:
		m.ClearCdnURL()
		return nil
	}
	return fmt.Errorf("unknown StorageProvider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StorageProviderMutation) ResetField(name string) error {
	switch name {
	case storageprovider.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case storageprovider.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case storageprovider.FieldState:
		m.ResetState()
		return nil
	case storageprovider.FieldName:
		m.ResetName()
		return nil
	case storageprovider.FieldBucket:
		m.ResetBucket()
		return nil
	case storageprovider.FieldSecretID:
		m.ResetSecretID()
		return nil
	case storageprovider.FieldSecretKey:
		m.ResetSecretKey()
		return nil
	case storageprovider.FieldEndpoint:
		m.ResetEndpoint()
		return nil
	case storageprovider.FieldFolder:
		m.ResetFolder()
		return nil
	case storageprovider.FieldRegion:
		m.ResetRegion()
		return nil
	case storageprovider.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case storageprovider.FieldUseCdn:
		m.ResetUseCdn()
		return nil
	case storageprovider.FieldCdnURL:
		m.ResetCdnURL()
		return nil
	}
	return fmt.Errorf("unknown StorageProvider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StorageProviderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cloudfiles != nil {
		edges = append(edges, storageprovider.EdgeCloudfiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StorageProviderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case storageprovider.EdgeCloudfiles:
		ids := make([]ent.Value, 0, len(m.cloudfiles))
		for id := range m.cloudfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StorageProviderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcloudfiles != nil {
		edges = append(edges, storageprovider.EdgeCloudfiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StorageProviderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case storageprovider.EdgeCloudfiles:
		ids := make([]ent.Value, 0, len(m.removedcloudfiles))
		for id := range m.removedcloudfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StorageProviderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcloudfiles {
		edges = append(edges, storageprovider.EdgeCloudfiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StorageProviderMutation) EdgeCleared(name string) bool {
	switch name {
	case storageprovider.EdgeCloudfiles:
		return m.clearedcloudfiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StorageProviderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown StorageProvider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StorageProviderMutation) ResetEdge(name string) error {
	switch name {
	case storageprovider.EdgeCloudfiles:
		m.ResetCloudfiles()
		return nil
	}
	return fmt.Errorf("unknown StorageProvider edge %s", name)
}
